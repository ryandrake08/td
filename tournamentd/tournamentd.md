# Tournament Daemon Protocol Documentation

This document provides comprehensive documentation of the Tournament Daemon (`tournamentd`) data structures, communication protocol, and client interface. This specification enables independent client development without requiring source code examination.

## Table of Contents

1. [Overview](#overview)
2. [Connection and Authentication](#connection-and-authentication)
3. [Data Structures](#data-structures)
4. [Command Protocol](#command-protocol)
5. [State Management](#state-management)
6. [Error Handling](#error-handling)

## Overview

The Tournament Daemon is a server application that manages poker tournament state and provides a JSON-based API for client applications. It supports both local Unix domain socket connections and TCP network connections with optional Bonjour/Zeroconf service discovery.

### Key Features
- Real-time tournament state management
- Multi-client support with authorization
- JSON-based command/response protocol
- Automatic seating and player management
- Configurable blind structures and payouts
- Tournament timing and clock management

### Network Architecture
- **Local Connections**: Unix domain sockets (e.g., `/tmp/tournamentd.25601.sock`)
- **Network Connections**: TCP sockets (default port: 25600)
- **Service Discovery**: Bonjour/Zeroconf publishing as `_pokerbuddy._tcp.local.`
- **Protocol**: Line-based JSON messages terminated with newline (`\n`)

## Connection and Authentication

### Connection Process

1. **Service Discovery**: Clients can discover tournaments via Bonjour/Zeroconf
2. **Socket Connection**: Connect to Unix socket (local) or TCP socket (remote)
3. **Authentication**: Send `authenticate` parameter with commands requiring authorization
4. **Authorization Check**: Use `check_authorized` command to verify permissions

### Authentication Mechanism

Most commands require an `authenticate` parameter with a numeric client identifier:

```json
{
  "authenticate": 12345,
  "echo": 1,
  ...command-specific parameters...
}
```

The client identifier is typically:
- Generated randomly (10000-99999 range)
- Stored persistently in client settings
- Used for all subsequent commands in the session

#### Commands Not Requiring Authentication

The following commands do not require an `authenticate` parameter:
- `version` - Returns server version information
- `get_state` - Returns current tournament state (read-only)
- `chips_for_buyin` - Calculates chip distribution (utility function)

#### Commands Requiring Authentication Parameter Only

- `check_authorized` - Requires `authenticate` parameter to check authorization status, but does not validate it

#### Commands Requiring Full Authorization

All other commands require the `authenticate` parameter and validate that the client is authorized before executing.

### Authorization

Clients must be pre-authorized by the tournament administrator. Use the `check_authorized` command to verify authorization status:

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 1
}
```

**Response:**
```json
{
  "echo": 1,
  "authorized": true
}
```

## Data Structures

The following data structures are exchanged between clients and the daemon via JSON serialization. Each structure includes details about internal representation and JSON serialization differences.

### Core Types

#### player_id_t
- **Type**: String identifier for players
- **Usage**: Unique key into the player database
- **JSON**: String value
- **Note**: In practice, this is typically a string representation of a UUID generated by clients

#### funding_source_id_t
- **Type**: Numeric index into funding sources array
- **Usage**: References buy-in, rebuy, or add-on options
- **JSON**: Number value

### Enumerations

#### funding_source_type_t
Tournament funding source types (serialized as integers):
- `0`: Initial tournament entry (buyin)
- `1`: Re-entry during rebuy period (rebuy)
- `2`: Optional chip addition (addon)

#### payout_policy_t
Payout calculation methods (serialized as integers):
- `0`: Calculated based on parameters (automatic)
- `1`: Single payout structure, regardless of number of players (forced)
- `2`: Manually-created payout structures, one for each number of players (manual)

#### rebalance_policy_t
Table rebalancing strategies (serialized as integers):
- `0`: Manual seat assignments only (manual)
- `1`: Automatic balance maintenance (automatic)
- `2`: Players play down to a single player on each table, who progresses (shootout)

#### ante_type_t
Ante posting methods (serialized as integers):
- `0`: No ante (none)
- `1`: All players post ante (traditional)
- `2`: Big blind ante (BB posts ante for table) (bba)

#### final_table_policy_t
Final table formation strategy (serialized as integers):
- `0`: Fill seats sequentially (fill)
- `1`: Random seat assignment (randomize)

### Primary Data Objects

#### authorized_client
Represents an authorized client connection.

**Structure:**
```cpp
struct authorized_client {
    int code;                // Client authentication code
    std::string name;        // Optional client name
    datetime added_at;       // When client was authorized
};
```

**JSON Serialization:**
```json
{
  "code": 12345,
  "name": "Tournament Controller",     // Optional, omitted if empty
  "added_at": "2023-12-01T10:30:00"    // Optional, omitted if default
}
```

**Serialization Notes:**
- `name` field omitted from JSON if empty string
- `added_at` field omitted from JSON if default datetime value
- Only `code` field is always present in JSON

#### blind_level
Defines blind structure for a tournament level.

**Structure:**
```cpp
struct blind_level {
    unsigned long little_blind;     // Small blind amount
    unsigned long big_blind;        // Big blind amount
    unsigned long ante;             // Ante amount (if applicable)
    ante_type_t ante_type;          // How ante is posted
    long duration;                  // Level duration in milliseconds
    long break_duration;            // Break after level in milliseconds
    std::string reason;             // Optional reason for the break (chip-up, dinner, etc.)
};
```

**JSON Serialization:**
```json
{
  "little_blind": 25,              // Omitted if 0
  "big_blind": 50,                 // Omitted if 0
  "ante": 5,                       // Omitted if 0
  "ante_type": 1,                  // Only present if ante > 0
  "duration": 1200000,             // Omitted if 0 (20 minutes in ms)
  "break_duration": 300000,        // Omitted if 0 (5 minute break)
  "reason": "Color up blacks"      // Omitted if empty
}
```

**Serialization Notes:**
- Zero-value numeric fields are omitted from JSON
- `ante_type` only included when `ante` > 0
- Empty strings are omitted from JSON
- All duration values are in milliseconds

#### chip
Represents a chip denomination in the tournament.

**Structure:**
```cpp
struct chip {
    std::string color;              // Chip color name
    unsigned long denomination;     // Chip value
    unsigned long count_available;  // Available quantity
};
```

**JSON Serialization:**
```json
{
  "denomination": 25,              // Always present
  "color": "green",                // Omitted if empty
  "count_available": 200           // Omitted if 0
}
```

**Serialization Notes:**
- `denomination` is always included in JSON
- `color` omitted if empty string
- `count_available` omitted if zero

#### table
Represents a tournament table.

**Structure:**
```cpp
struct table {
    std::string table_name;         // Table identifier
};
```

**JSON Serialization:**
```json
{
  "table_name": "Table 1"         // Omitted if empty
}
```

#### monetary_value
Represents a monetary amount with currency.

**Structure:**
```cpp
struct monetary_value {
    double amount;                  // Monetary amount
    std::string currency;           // ISO 4217 currency code
};
```

**JSON Serialization:**
```json
{
  "amount": 50.00,               // Always present
  "currency": "USD"              // Omitted if empty
}
```

#### monetary_value_nocurrency
Represents a monetary amount without currency (inherits tournament's payout currency).

**Structure:**
```cpp
struct monetary_value_nocurrency {
    double amount;                  // Monetary amount
};
```

**JSON Serialization:**
```json
{
  "amount": 1500.00              // Always present
}
```

#### funding_source
Defines a tournament funding option (buy-in, rebuy, add-on).

**Structure:**
```cpp
struct funding_source {
    std::string name;                          // Funding source name
    funding_source_type_t type;               // Source type
    std::size_t forbid_after_blind_level;    // Cutoff level
    unsigned long chips;                      // Chips awarded
    monetary_value cost;                      // Entry cost
    monetary_value commission;                // House commission
    monetary_value_nocurrency equity;         // Tournament equity value
};
```

**JSON Serialization:**
```json
{
  "name": "Main Buy-in",
  "type": "buyin",
  "chips": 3000,
  "cost": {"amount": 50.00, "currency": "USD"},
  "commission": {"amount": 5.00, "currency": "USD"},
  "equity": {"amount": 45.00},
  "forbid_after_blind_level": 8            // When omitted, it means funding option is available throughout the tournament
}
```

**Serialization Notes:**
- All fields except `forbid_after_blind_level` are always present
- `forbid_after_blind_level` omitted when set to `std::numeric_limits<std::size_t>::max()`

#### player
Represents a tournament participant.

**Structure:**
```cpp
struct player {
    player_id_t player_id;         // Unique player identifier
    std::string name;              // Player display name
    datetime added_at;             // Registration timestamp
};
```

**JSON Serialization:**
```json
{
  "player_id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "John Smith",
  "added_at": "2023-12-01T09:15:30"
}
```

**Serialization Notes:**
- All fields are always present in JSON
- `added_at` uses ISO 8601 datetime format

#### seat
Represents a physical seat at a tournament table.

**Structure:**
```cpp
struct seat {
    std::size_t table_number;      // Table index
    std::size_t seat_number;       // Seat index at table
};
```

**JSON Serialization:**
```json
{
  "table_number": 1,
  "seat_number": 3
}
```

#### player_movement
Describes player movement between seats.

**Structure:**
```cpp
struct player_movement {
    player_id_t player_id;         // Player being moved
    std::string name;              // Player name
    std::string from_table_name;   // Source table
    std::string from_seat_name;    // Source seat
    std::string to_table_name;     // Destination table
    std::string to_seat_name;      // Destination seat
};
```

**JSON Serialization:**
```json
{
  "player_id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "John Smith",
  "from_table_name": "Table 1",
  "from_seat_name": "Seat 3",
  "to_table_name": "Table 2",
  "to_seat_name": "Seat 7"
}
```

**Serialization Notes:**
- All fields always present (may be empty strings for unseating)

#### player_chips
Represents chip distribution to a player.

**Structure:**
```cpp
struct player_chips {
    unsigned long denomination;     // Chip denomination
    unsigned long chips;           // Chip quantity
};
```

**JSON Serialization:**
```json
{
  "denomination": 25,
  "chips": 12
}
```

#### result
Represents final tournament placement.

**Structure:**
```cpp
struct result {
    size_t place;                           // Finishing position (1st, 2nd, etc.)
    std::string name;                       // Player name
    monetary_value_nocurrency payout;      // Prize amount
};
```

**JSON Serialization:**
```json
{
  "place": 1,
  "name": "John Smith",
  "payout": {"amount": 1500.00}
}
```

#### seated_player
Represents a player with seating information.

**Structure:**
```cpp
struct seated_player {
    player_id_t player_id;         // Player identifier
    bool buyin;                    // Has bought in
    std::string player_name;       // Player name
    std::string table_name;        // Assigned table (if seated)
    std::string seat_name;         // Assigned seat (if seated)
    seat seat_position;            // Numeric table and seat numbers
};
```

**JSON Serialization (unseated):**
```json
{
  "player_id": "550e8400-e29b-41d4-a716-446655440000",
  "buyin": true,
  "player_name": "John Smith",
  "seat_position": {
    "table_number": 0,
    "seat_number": 0
  }
}
```

**JSON Serialization (seated):**
```json
{
  "player_id": "550e8400-e29b-41d4-a716-446655440000",
  "buyin": true,
  "player_name": "John Smith",
  "table_name": "Table 1",
  "seat_name": "Seat 3",
  "seat_position": {
    "table_number": 1,
    "seat_number": 3
  }
}
```

**Serialization Notes:**
- Table and seat information only included when player is seated
- Conditional serialization based on `seat_name.empty()`
- `seat_position` always included with numeric table and seat numbers
- For unseated players, `seat_position` contains zeros

#### seating_chart_entry
Represents seating chart information for display.

**Structure:**
```cpp
struct seating_chart_entry {
    std::string player_name;       // Player name (empty if unoccupied)
    std::string table_name;        // Table name
    std::string seat_name;         // Seat name
};
```

**JSON Serialization (empty seat):**
```json
{
  "table_name": "Table 1",
  "seat_name": "Seat 5"
}
```

**JSON Serialization (occupied seat):**
```json
{
  "player_name": "John Smith",
  "table_name": "Table 1",
  "seat_name": "Seat 5"
}
```

**Serialization Notes:**
- `player_name` only included for occupied seats
- Conditional serialization based on `player_name.empty()`

#### manual_payout
Defines a manually configured payout structure.

**Structure:**
```cpp
struct manual_payout {
    size_t buyins_count;                                    // Number of buy-ins this applies to
    std::vector<monetary_value_nocurrency> payouts;        // Prize amounts
};
```

**JSON Serialization:**
```json
{
  "buyins_count": 20,
  "payouts": [
    {"amount": 800.00},
    {"amount": 500.00},
    {"amount": 300.00},
    {"amount": 200.00}
  ]
}
```

#### automatic_payout_parameters
Configuration for automatic payout calculation.

**Structure:**
```cpp
struct automatic_payout_parameters {
    double percent_seats_paid;     // Percentage of field getting paid (0.0-1.0)
    bool round_payouts;           // Round to whole dollar amounts
    double payout_shape;          // Payout distribution curve
    double pay_the_bubble;        // Bubble compensation (0.0-1.0)
    double pay_knockouts;         // Knockout bounty percentage (0.0-1.0)
};
```

**JSON Serialization:**
```json
{
  "percent_seats_paid": 0.15,
  "round_payouts": true,
  "payout_shape": 0.65,
  "pay_the_bubble": 0.0,
  "pay_knockouts": 0.0
}
```

**Serialization Notes:**
- All fields are always present in JSON
- No conditional serialization for this structure

### DateTime Handling

The daemon uses custom `datetime` and `std::chrono::system_clock::time_point` types for timestamps.

#### datetime Serialization
- **Internal**: Custom datetime class
- **JSON**: ISO 8601 string format (`"2023-12-01T10:30:00"`)
- **Functions**: `to_json()` calls `datetime.gmtime()`, `from_json()` calls `datetime::from_gm()`

#### time_point Serialization
- **Internal**: `std::chrono::system_clock::time_point`
- **JSON**: Milliseconds since epoch as number
- **Functions**: Converts via `duration_cast<milliseconds>().count()`

## Command Protocol

All client-server communication follows a request-response pattern using JSON messages. Each message is terminated with a newline character (`\n`).

### Message Structure

#### Request Format
```json
{
  "authenticate": 12345,           // Required: Client auth code
  "echo": 123,                    // Required: Command sequence number
  ...command-specific parameters...
}
```

#### Response Format
```json
{
  "echo": 123,                    // Matches request echo value
  ...command-specific response data...
}
```

#### Broadcast Messages
The daemon sends unsolicited state updates without echo values:
```json
{
  ...current tournament state...
}
```

### Command Reference

#### Authorization Commands

##### check_authorized
Verify client authorization status.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 1
}
```

**Response:**
```json
{
  "echo": 1,
  "authorized": true
}
```

##### version
Get daemon version information. (No authentication required)

**Request:**
```json
{
  "echo": 2
}
```

**Response:**
```json
{
  "echo": 2,
  "server_name": "tournamentd",
  "server_version": "0.0.9"
}
```

#### Configuration Commands

##### get_config
Retrieve current tournament configuration.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 3
}
```

**Response:**
```json
{
  "echo": 3,
  "blind_levels": [...],
  "funding_sources": [...],
  "players": [...],
  "tables": [...],
  "chips": [...],
  ...configuration parameters...
}
```

##### configure
Update tournament configuration (must be authorized).

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 4,
  "blind_levels": [...],
  "funding_sources": [...],
  "players": [...],
  ...configuration updates...
}
```

**Response:**
```json
{
  "echo": 4,
  "configured": 15          // Number of configuration items processed
}
```

##### reset_state
Reset tournament to initial state (must be authorized).

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 5
}
```

**Response:**
```json
{
  "echo": 5
}
```

#### State Management Commands

##### get_state
Retrieve current tournament state. (No authentication required)

**Request:**
```json
{
  "echo": 6
}
```

**Response:**
```json
{
  "echo": 6,
  "running": false,
  "current_blind_level": 0,
  "current_time": 1701425400000,
  "end_of_round": 1701426600000,
  "seated_players": [...],
  "results": [...],
  ...complete tournament state...
}
```

#### Tournament Control Commands

##### start_game
Start the tournament.

**Request (immediate start):**
```json
{
  "authenticate": 12345,
  "echo": 7
}
```

**Request (scheduled start):**
```json
{
  "authenticate": 12345,
  "echo": 7,
  "start_at": 1701425400000     // Milliseconds since epoch
}
```

**Response:**
```json
{
  "echo": 7
}
```

##### stop_game
Stop the tournament.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 8
}
```

**Response:**
```json
{
  "echo": 8
}
```

##### pause_game
Pause the tournament timer.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 9
}
```

**Response:**
```json
{
  "echo": 9
}
```

##### resume_game
Resume the tournament timer.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 10
}
```

**Response:**
```json
{
  "echo": 10
}
```

##### toggle_pause_game
Toggle tournament pause state.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 11
}
```

**Response:**
```json
{
  "echo": 11
}
```

#### Blind Level Commands

##### set_previous_level
Move to previous blind level.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 12
}
```

**Response:**
```json
{
  "echo": 12,
  "blind_level_changed": 2      // New blind level index
}
```

##### set_next_level
Move to next blind level.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 13
}
```

**Response:**
```json
{
  "echo": 13,
  "blind_level_changed": 4      // New blind level index
}
```

##### set_action_clock
Set tournament action clock timer.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 14,
  "duration": 60000            // Duration in milliseconds
}
```

**Response:**
```json
{
  "echo": 14
}
```

#### Utility Commands

##### gen_blind_levels
Generate blind level structure.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 15,
  "starting_chips": 3000,
  "target_duration": 180,       // Minutes
  "level_duration": 20,        // Minutes per level
  "structure": "standard"      // or "turbo", "deep"
}
```

**Response:**
```json
{
  "echo": 15,
  "blind_levels": [
    {"little_blind": 25, "big_blind": 50, "duration": 1200000},
    {"little_blind": 50, "big_blind": 100, "duration": 1200000},
    ...
  ]
}
```

##### chips_for_buyin
Calculate chip distribution for buy-in. (No authentication required)

**Request:**
```json
{
  "echo": 16,
  "source_id": 0,              // Funding source index
  "max_expected_players": 20
}
```

**Response:**
```json
{
  "echo": 16,
  "chips_for_buyin": [
    {"denomination": 25, "chips": 8},
    {"denomination": 100, "chips": 7},
    {"denomination": 500, "chips": 4}
  ]
}
```

#### Player Management Commands

##### fund_player
Add buy-in/rebuy/add-on for a player.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 17,
  "player_id": "550e8400-e29b-41d4-a716-446655440000",
  "source_id": 0               // Funding source index
}
```

**Response:**
```json
{
  "echo": 17
}
```

#### Seating Commands

##### plan_seating
Generate seating plan for expected players.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 18,
  "max_expected_players": 30
}
```

**Response:**
```json
{
  "echo": 18,
  "players_moved": [...]       // Array of player_movement objects
}
```

##### seat_player
Seat a player at optimal available seat.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 19,
  "player_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Response (newly seated):**
```json
{
  "echo": 19,
  "player_seated": {
    "player_id": "550e8400-e29b-41d4-a716-446655440000",
    "table_name": "Table 1",
    "seat_name": "Seat 3"
  }
}
```

**Response (already seated):**
```json
{
  "echo": 19,
  "already_seated": {
    "player_id": "550e8400-e29b-41d4-a716-446655440000",
    "table_name": "Table 1",
    "seat_name": "Seat 3"
  }
}
```

##### unseat_player
Remove player from their current seat.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 20,
  "player_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Response:**
```json
{
  "echo": 20
}
```

##### bust_player
Eliminate player from tournament.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 21,
  "player_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Response:**
```json
{
  "echo": 21,
  "players_moved": [...]       // Resulting seating changes
}
```

##### rebalance_seating
Rebalance players across tables.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 22
}
```

**Response:**
```json
{
  "echo": 22,
  "players_moved": [...]       // Array of player_movement objects
}
```

##### quick_setup
Perform initial tournament setup with current players.

**Request:**
```json
{
  "authenticate": 12345,
  "echo": 23
}
```

**Response:**
```json
{
  "echo": 23,
  "seated_players": [...]      // Array of seated_player objects
}
```

## State Management

The daemon maintains comprehensive tournament state and broadcasts changes to all connected clients.

### State Broadcasting

State updates are sent automatically to all connected clients when tournament state changes. These messages do not contain an `echo` field:

```json
{
  "current_time": 1701425450000,
  "running": true,
  "current_blind_level": 3,
  "end_of_round": 1701426600000,
  "seated_players": [...],
  ...updated state fields...
}
```

### Key State Fields

#### Tournament Status
- `running` (boolean): Tournament is active
- `current_time` (number): Current server timestamp (ms since epoch)
- `tournament_start` (number): Tournament start time (ms since epoch)
- `paused_time` (number): Accumulated pause time in milliseconds

#### Timing Information
- `current_blind_level` (number): Current blind level index
- `end_of_round` (number): When current level ends (ms since epoch)
- `end_of_break` (number): When break ends (ms since epoch, if in break)
- `action_clock_time_remaining` (number): Action clock milliseconds remaining
- `end_of_action_clock` (number): When action clock expires (ms since epoch)

#### Player Information
- `players` (array): All registered players
- `seated_players` (array): Players with seating assignments
- `entries` (number): Total number of entries/buy-ins
- `unique_entries` (number): Number of unique players
- `players_finished` (number): Number of eliminated players

#### Seating Information
- `seating_chart` (array): Complete seating chart with all seats
- `available_tables` (array): Available table configurations
- `seats` (array): All seat definitions
- `empty_seats` (number): Number of unoccupied seats
- `table_count` (number): Number of active tables
- `tables_playing` (array): List of active tables

#### Financial Information
- `total_cost` (object): Total buy-in costs collected
- `total_commission` (object): Total house commission
- `total_equity` (object): Total prize pool equity
- `total_chips` (number): Total chips in play
- `payout_currency` (string): Tournament payout currency code
- `payouts` (array): Current payout structure

#### Tournament Configuration
- `name` (string): Tournament name
- `background_color` (string): UI background color preference
- `buyin_text` (string): Display text for buy-in information
- `funding_sources` (array): Available buy-in/rebuy/add-on options
- `available_chips` (array): Available chip denominations
- `buyins` (array): Historical buy-in transactions
- `bust_history` (array): Player elimination history
- `results` (array): Final tournament results

## Error Handling

### Protocol Errors

The daemon returns error responses for invalid requests using one of two formats:

**Protocol Errors (business logic violations):**
```json
{
  "echo": 123,
  "error": "unauthorized"
}
```

**System Exceptions (unexpected errors):**
```json
{
  "echo": 123,
  "exception": "std::out_of_range exception message"
}
```

### Actual Error Messages

The following error messages are emitted by the tournament daemon code:

#### Authorization Errors
- `"unauthorized"` - Client authentication failed (from `ensure_authorized()`)

#### Command Errors
- `"unknown command"` - Unrecognized command name

#### Configuration Errors
- `"players_count must be non-zero"` - Invalid player count for calculations
- `"denomination not found in chip set"` - Referenced chip denomination doesn't exist
- `"tried to look up a funding source with none defined"` - No funding sources configured
- `"no funding sources of given type exist"` - Requested funding type not available
- `"table capacity must be at least 2"` - Invalid table capacity setting
- `"not enough blind levels configured"` - Insufficient blind structure
- `"tried to create a blind structure without chips defined"` - Missing chip configuration

#### Tournament State Errors
- `"tournament already started"` - Operation not allowed after tournament begins
- `"tournament not started"` - Operation requires active tournament
- `"tournament already paused"` - Cannot pause already paused tournament
- `"tournament not paused"` - Cannot resume unpaused tournament
- `"cannot start without blind levels configured"` - Missing required blind structure

#### Player Management Errors
- `"tried to seat a player that is already seated"` - Player seating conflict
- `"tried to remove player not seated"` - Cannot unseat player not at table
- `"tried to bust player not bought in"` - Cannot eliminate player without buy-in
- `"invalid funding source"` - Referenced funding source doesn't exist
- `"too late in the game for this funding source"` - Funding cutoff exceeded
- `"tried a non-buyin funding source but not bought in yet"` - Rebuy/addon without initial buy-in
- `"tried re-buying before tournamnet start"` - Timing violation for rebuys

#### Seating Management Errors
- `"tried to move player to a full table"` - No available seats at target table
- `"tried to move player to another table but no candidate tables"` - No suitable tables for movement
- `"expected players must be at least 2"` - Invalid seating plan parameters
- `"expected players less than currently seated players"` - Seating plan conflict

#### Chip Management Errors
- `"tried to calculate chips for a buyin without chips defined"` - Missing chip configuration
- `"smallest chip available is larger than the smallest little blind"` - Chip/blind mismatch
- `"buyin is not a multiple of the smallest chip available"` - Buy-in amount incompatible with chips

#### Clock Management Errors
- `"current blind level out of bounds"` - Invalid blind level reference
- `"only one action clock at a time"` - Action clock already running

#### Setup Errors
- `"cannot quick setup with no funding sources"` - Quick setup requires funding options
- Various blind structure generation errors for invalid parameters

### Connection Handling

#### Network Disconnections
- Clients should implement reconnection logic
- State is preserved during temporary disconnections
- Long disconnections may result in session timeout

#### Graceful Shutdown
- Daemon sends disconnect notification before shutdown
- Clients should save state and attempt reconnection
- Tournament state is persisted across daemon restarts

## JSON Data Structure Reference

The tournament daemon provides tournament information through four distinct JSON dump methods. Each serves a different purpose and contains specific fields that clients need to understand.

### dump_configuration(config)

Contains complete tournament configuration that rarely changes. Used for initial client setup and configuration dialogs.

**Configuration Fields:**
```json
{
  "name": "Tournament Name",                         // Tournament display name
  "players": [...],                                  // Array of all registered players
  "table_capacity": 9,                               // Maximum players per table
  "table_names": ["Table 1", "Table 2"],             // Available table names
  "payout_policy": "automatic",                      // Payout calculation method
  "payout_currency": "USD",                          // Currency for payouts
  "automatic_payouts": {...},                        // Automatic payout parameters
  "forced_payouts": [...],                           // Fixed payout structure
  "manual_payouts": [...],                           // Manual payout overrides
  "previous_blind_level_hold_duration": 30000,       // ms to wait before allowing previous round
  "rebalance_policy": "fill_tables",                 // Player movement policy
  "background_color": "#000000",                   // Clock display background color
  "final_table_policy": "fill_in",                   // Final table seating method
  "funding_sources": [...],                          // Available buy-ins/rebuys
  "blind_levels": [...],                             // Complete blind structure
  "available_chips": [...],                          // Chip denominations and colors
  "available_tables": [...]                          // Table configurations
}
```

### dump_state(state)

Contains current tournament state that changes during play. This is the primary game state.

**State Fields:**
```json
{
  "seats": [...],                                    // All table/seat assignments
  "players_finished": [...],                         // Players eliminated/finished
  "bust_history": [...],                             // Elimination order and times
  "empty_seats": [...],                              // Available seats
  "table_count": 3,                                  // Number of active tables
  "buyins": [...],                                   // All player buy-in records
  "unique_entries": 45,                              // Distinct players who entered
  "entries": 47,                                     // Total entries (including rebuys)
  "payouts": [...],                                  // Calculated prize distribution
  "total_chips": 150000,                             // Total chips in play
  "total_cost": 2350.00,                             // Total money collected
  "total_commission": 235.00,                        // House commission taken
  "total_equity": 2115.00,                           // Prize pool amount
  "current_blind_level": 4,                          // Current round index (0-based)
  "end_of_round": 1703181600000,                     // Round end timestamp (ms since epoch)
  "end_of_break": 0,                                 // Break end timestamp (0 if not on break)
  "end_of_action_clock": 0,                          // Action clock end (0 if not active)
  "tournament_start": 1703178000000,                 // Tournament start timestamp
  "paused_time": 0                                   // Accumulated pause time (ms)
}
```

### dump_configuration_state(state)

Contains configuration items that are commonly needed with state updates. Sent along with state for client convenience.

**Configuration State Fields:**
```json
{
  "name": "Tournament Name",                         // Tournament display name
  "background_color": "#000000",                     // Clock background color
  "funding_sources": [...],                          // Available buy-ins (for display)
  "available_chips": [...],                          // Chip info (for chip display)
  "available_tables": [...],                         // Table configurations
  "payout_currency": "USD"                           // Currency symbol
}
```

### dump_derived_state(state)

Contains calculated/derived values that are computed in real-time, not stored as member variables.

**Derived State Fields:**
```json
{
  "current_time": 1703181550000,                     // Server time (ms since epoch) - for sync
  "elapsed_time": 3550000,                           // Time since tournament start (ms)
  "action_clock_time_remaining": 45000,              // Action clock countdown (ms, 0 if inactive)
  "running": true,                                   // Tournament active (not paused)
  "time_remaining": 450000,                          // Round time left (ms)
  "clock_remaining": 450000,                         // Clock display time (round or break)
  "on_break": false,                                 // Currently on break
  "current_round_text": "200/400 (50)",             // Current round description
  "next_round_text": "300/600 (75)",                // Next round description
  "buyin_text": "$50 + $5 (3000 chips)",            // Formatted buyin description
  "current_round_number_text": "5",                 // Current round number as formatted text
  "players_left_text": "23",                        // Players remaining as formatted text
  "entries_text": "45",                             // Total entries as formatted text
  "average_stack_text": "6,521",                   // Average stack as formatted text with commas
  "elapsed_time_text": "2:15:30",                  // Elapsed time as formatted HH:MM:SS text
  "clock_text": "12:45",                            // Tournament clock as formatted MM:SS text
  "break_time_remaining": 0                          // Break countdown (ms, 0 if not on break)
}
```

### Client Data Access Patterns

Based on this structure, clients should access tournament data as follows:

**Tournament Info Display:**
- Tournament name: `state.name`
- Buyin information: `state.buyin_text` (formatted description from derived state)

**Tournament Statistics:**
- Current round: `state.current_round_number_text` (formatted text)
- Players left: `state.players_left_text` (formatted text)
- Total entries: `state.entries_text` (formatted text)
- Average stack: `state.average_stack_text` (formatted text with commas)

**Time Display:**
- Elapsed time: `state.elapsed_time_text` (formatted HH:MM:SS text)
- Clock display: `state.clock_text` (formatted MM:SS text)
- Tournament clock: Use `state.clock_text` directly

**Round Information:**
- Current round info: `state.current_round_text` (formatted string)
- Next round info: `state.next_round_text` (formatted string)
- Blind levels: `state.configuration.blind_levels` (array of blind structures)

**Chip Information:**
- Available chips: `state.configuration.available_chips`
- Each chip has: `{name: "Color", value: denomination}`

**Results Display:**
- Tournament results: `state.payouts` (final standings and prizes)
- Results format: `{place: N, name: "Player", payout: {amount: X.XX}}`

### Important Notes

1. **Time Synchronization**: Use `current_time` from derived state for client-server sync
2. **Derived vs Stored**: Derived state is calculated each time, stored state persists
3. **Configuration Overlap**: Some config items appear in both configuration and configuration_state. Clients should heavily favor reading these items from state instead of configuration. Configuration should rarely need to be read and acted upon by the client.
4. **Real-time Updates**: State and derived state change frequently, configuration rarely changes
5. **Time Formats**: All timestamps are milliseconds since Unix epoch
6. **Round Indexing**: `current_blind_level` is 0-based, display as 1-based to users

---

*This documentation covers Tournament Daemon protocol version 1.0. For implementation questions or protocol extensions, refer to the source code in the `tournamentd/` directory.*